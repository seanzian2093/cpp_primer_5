#include <iostream>
#include <algorithm>
#include "../ch12/text_query.hpp"

// Abstrct class acts as a base class for concrete query types; 
    // - all members are private
        // - we do not intent users or derived classes to use Query_base directly
class Query_base {
    // - all use of Query_base will be through Query objects. so we grant friendship to Query class
        // - 
    friend class Query;
protected:
    // line_no will be used inside the eval member
    using line_no = TextQuery::line_no;
    // destructor is implicitly used by the destructors in the derived classes
    virtual ~Query_base() = default;
private:
    // return QueryResult that matches this Query
        // - `=0` makes it pure virtual, i.e., derived class must override it, otherwise derived class become abstrct class
    virtual QueryResult eval(const TextQuery&) const = 0;
    // rep is a string representation of the query
    virtual std::string rep() const = 0;
};

// Interface class

class Query {
    // these operators need access to the privat constructor
    friend Query operator~(const Query &);
    friend Query operator|(const Query &, const Query &);
    friend Query operator&(const Query &, const Query &);
public:
    // delcare constructor, define later
    Query(const std::string&);
    // override eval
        // - use pointer to Query_base to call Query_base operation, i.e. static type
            // - actual version, i.e., dynamic version will be 
                // - determined at run time
                // - dependent on the objects which q points to
    QueryResult eval(const TextQuery &t) const { return q->eval(t); }
    // override rep
    std::string rep() const { return q->rep(); }
private:
    // declare constructor - private
        // - not define yet
    Query(std::shared_ptr<Query_base> query) : q(query) { }
    std::shared_ptr<Query_base> q;
};

// Output operator
std::ostream & operator <<(std::ostream &os, const Query &query)
{
    // call Query::rep() which is public
        // - whici makes a virtual call through Query_base pointer to Query_base::rep
            // - the actuall version called is dynamic
    return os << query.rep();
}

// Workload class
class WordQuery: public Query_base {
    // makes Query a friend because in Query constructor, WordQuery constructor will be used
    friend class Query;
    // constructor
WordQuery(const std::string &s) : query_word(s) {}

    // override virtual functions inherited from base
        // - perform the real workload
QueryResult eval(const TextQuery &t) const { return t.query(query_word); }
std::string rep() const { return query_word; }
std::string query_word;
};

inline Query::Query(const std::string &s) : q(new WordQuery(s)) { }

// NotQuery
    // - generated by `operator~`
    // - holds a Query which it negates
class NotQuery: public Query_base {
    // all membes are private
        // make `operator~` a friend so it can access members
    friend Query operator~(const Query&);
    NotQuery(const Query &q): query(q) {}
    // query.rep() is Query::rep() which in turn calls Query_base::rep()
        // - a virtual call
    std::string rep() const { return "~(" + query.rep() + ")"; }
    QueryResult eval(const TextQuery&) const;
    Query query;
};
// define `operator~`
    // - return a pointer to a NotQuery object
inline Query operator~(const Query &operand)
{
    return std::shared_ptr<Query_base>(new NotQuery(operand));
}

// BinaryQuery 
    // - is an abstract class
    // - base of AndQuery and OrQuery
class BinaryQuery: public Query_base {
protected:
    BinaryQuery(const Query &l, const Query &r, std::string s): lhs(l), rhs(r), opSym(s) { }
    // BinaryQuery is an abstract class since it does not override all pure virtual functions of Query_base
        // - eval() is not overrided
    std::string rep() const { return "(" + lhs.rep() + " " + opSym + " " + rhs.rep() + ")"; }
    Query lhs, rhs;
    std::string opSym;
};

// AndQuery
class AndQuery: public BinaryQuery {
    friend Query operator& (const Query&, const Query&);
    AndQuery(const Query &left, const Query &right): BinaryQuery(left, right, "&") { }
    // only one pure virtual function inherits from BinaryQuery, eval
        // - overfiding it makes AndQuery a concrete class
    QueryResult eval(const TextQuery&) const;
};
inline Query operator& (const Query &lhs, const Query &rhs)
{
    return std::shared_ptr<Query_base>(new AndQuery(lhs, rhs));
}

// OrQuery
class OrQuery: public BinaryQuery {
    friend Query operator| (const Query&, const Query&);
    OrQuery(const Query &left, const Query &right): BinaryQuery(left, right, "|") { }
    // only one pure virtual function inherits from BinaryQuery, eval
        // - overfiding it makes OrQuery a concrete class
    QueryResult eval(const TextQuery&) const;
};
inline Query operator| (const Query &lhs, const Query &rhs)
{
    return std::shared_ptr<Query_base>(new OrQuery(lhs, rhs));
}

// eval() of concreate classes
QueryResult OrQuery::eval(const TextQuery& text) const
{
    // core of OrQuery - query of right and left operand
    auto right = rhs.eval(text), left = lhs.eval(text);
    auto ret_lines = std::make_shared<std::set<line_no>>(left.begin(), left.end());
    // and merge together - union
    ret_lines->insert(right.begin(), right.end());

    return QueryResult(rep(), ret_lines, left.get_file());
}

QueryResult AndQuery::eval(const TextQuery & text) const
{
    // core of AndQuery - query of right and left operand
    auto right = rhs.eval(text), left = lhs.eval(text);
    auto ret_lines = std::make_shared<std::set<line_no>>();
    // and merge together - intersection
        // - set_intersection() takes 5 iterators
            // - 1st and 2nd to denote one set
            // - 3rd and 4th to denote another set
            // - 5th to denote a desination, where the algorithm write common elements to
    std::set_intersection(left.begin(), left.end(), right.begin(), right.end(), inserter(*ret_lines, ret_lines->begin()));

    return QueryResult(rep(), ret_lines, left.get_file());
}

QueryResult NotQuery::eval(const TextQuery & text) const
{
    auto result = query.eval(text);
    auto ret_lines = std::make_shared<std::set<line_no>>();
    auto beg = result.begin(), end = result.end();
    auto sz = result.get_file()->size();
    for (size_t n = 0; n != sz; ++n) {
        //
        if (beg == end || *beg != n)
            ret_lines->insert(n);
        else if (beg != end)
            ++beg;
    }

    return QueryResult(rep(), ret_lines, result.get_file());
}
