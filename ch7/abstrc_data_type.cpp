
#include <iostream>

// Struct/class
    // - Functions defined in the class/struct are impicitly inline
    // - Every member must be declared inside its class
        // - can be defined either inside or outside 
    // - a struct/class is a scope
        // - compiler handles member declarations and then
        // - handles definition so isbn() can use bookNo which is defined in later line

struct Sales_data {
    // Constructors
        // - have same name as the class
        // - is functions that have no return type
        // - is overloaded functions that they must differ in number or types of parameter
        // - may not be declared as const
            // - when create const object, the object does not assume const-ness untill after its constructors complete init
                // - constructors can write to const objects during construction, i.e., initializations
        // - default constructor takes no arguments 
            // - and is automatically implicitly generated by compiler only when there is no any constructors
            // - such constructors are known as synthesized default constructor
                // - use in-class initializer to init the member if there is such, e.g., units_sold, revenue
                // - otherwise use default initialization
                    // - for built-in types/array/pointer, they are initialized to zero if defined outside a function/block
                    // - uninitialized if defined in a fucntion, undefined
            // - compiler could fail to generate a synthesized constructor
    
        // - default constructor - explicitly defined since compiler will not because we are doing to define more constructors
            // - the one would be generated by compiler if we did not define more constructors.
            // - `= default` can be with declaration inside class/struct, default constructor will be inline 
            // - `= default` can be with definition outside class/struct, default constructor will not be inline 
    Sales_data() = default;
        // - more self-defined constructors
            // - function body is empty {}
            // - after the colon `:` and before the function body{}, constructor initializer list
                // - a list of one or more members to be initialized, with init value in (), separated by comma
            // - should not override in-class initializers except to use a different value
            // - if we cannot use in-class initializers, each constructor should explicitly initialize every member of built-in type
                // - otherwise they will be undefined.

            // - 1st takes a ref to string, and init bookNo with the string, 
                // - other omitted members are initialized as if by synthesized default constructor
    Sales_data(const std::string &s) : bookNo(s) {}
    Sales_data(const std::string &s, unsigned n, double p) :
               bookNo(s), units_sold(n), revenue(p*n) {}

            // - can be defined outside, declaration must be inside
    Sales_data(std::istream &is);
    // operations on Sales_data objects
        // - implicitly returns bookNo of the object on which the isbn() is called on, i.e., self.bookNo in Python 
    std::string isbn() const { return bookNo; }
        // - when call a member function, `this`, a const pointer to the object on which isbn() is called, is automatically initialized 
        // - so we can use arrow operator on `this`, similar to self.bookNo in Python
        // - `const` is used to modify `this`
            // - from a `const pointer to non-const` to a `const pointer to const` 
            // - so that `this` can point to a const
            // - member functions likef isbn() can only read, not modify the underlying object
        // - we can not call ordinary member function on a const object
            // - because without `const` modifying `this`, `this` cannot points to such const object
            // - ordinary member function mean a function without such const modifier
            // - Objects that are const, refs and pointers to const objects can only call const member function, i.e. modified by const, like isbn()
    // std::string isbn2() const { return this->bookNo; }
    Sales_data & combine(const Sales_data&);
    double avg_price() const;

    // data members
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;

// struct definition ends with a semicolon;

};

// nonmembers, interface functions
    // - operations that are not class itself, but conceptually related
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);

// - Define member functions outside
    // - using scope operator indicate that we are defining avg_price() which is declared in Sales_data
    // - must specify the const modifier if avg_price is declared as const
double Sales_data::avg_price() const {
    // units_sold, revenue are automatically resolved to members of Sales_data
    if (units_sold)
        return revenue/units_sold;
    else
        return 0;
}

Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    // we need to use `this` to access to calling object as a whole
    return *this;
}

// Read from an istream into a Sales_data object
    // - Io class type cannot be copied, so pass by a ref 
    // - reading or writing from a stream changes that stream, so parameters should not be const
std::istream &read(std::istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}

// Print the contents of a Sales_data object on an ostream
std::ostream &print(std::ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " " << item.revenue << " " << item.avg_price();
    return os;
}

Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;
    sum.combine(rhs);
    return sum;
}

Sales_data::Sales_data(std::istream &is)
{
    read(is, *this);
}


// Copy, Assignment, and Destruction
    // - we need to define copy, assignmen, and destruction operation for class that we defined
    // - otherwise compiler will synthesize them for us
        // - ordinarily, this is done by copying/assigning/destroying each member of the object
        // - synthesized versions of copy, assignment, and destruction work correctly for classes that have
            // - vector members or
            // - string members
    // - ch13 discuss how to define own version of such operations
int main()
{
    Sales_data sd;
    print(std::cout, sd);
    std::cout << std::endl;

    Sales_data sd2("Init by s");
    print(std::cout, sd2);
    std::cout << std::endl;

    Sales_data sd3("Init by s, n, p", 25, 44.4);
    print(std::cout, sd3);
    std::cout << std::endl;

    Sales_data sd4(std::cin);
    print(std::cout, sd4);
    std::cout << std::endl;

    return 0;
}